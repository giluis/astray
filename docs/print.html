<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Example book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="The example book covers examples.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="project_structure.html">Project structure</a></li><li class="chapter-item expanded affix "><li class="part-title">Astray Basics</li><li class="chapter-item expanded "><a href="compiler_primer.html"><strong aria-hidden="true">1.</strong> A primer on compilers</a></li><li class="chapter-item expanded "><a href="what_is_astray.html"><strong aria-hidden="true">2.</strong> What is Astray</a></li><li class="chapter-item expanded "><a href="basic_usage.html"><strong aria-hidden="true">3.</strong> Basic Usage</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="structs.html"><strong aria-hidden="true">3.1.</strong> Structs</a></li><li class="chapter-item expanded "><a href="enums.html"><strong aria-hidden="true">3.2.</strong> Enums</a></li><li class="chapter-item expanded "><a href="pattern_matching.html"><strong aria-hidden="true">3.3.</strong> Pattern matching</a></li></ol></li><li class="chapter-item expanded "><a href="std_types.html"><strong aria-hidden="true">4.</strong> Additional Types</a></li><li class="chapter-item expanded "><a href="std_types.html"><strong aria-hidden="true">5.</strong> Custom Types</a></li><li class="chapter-item expanded "><a href="errors.html"><strong aria-hidden="true">6.</strong> Errors</a></li><li class="chapter-item expanded affix "><li class="part-title">Inner Workings</li><li class="chapter-item expanded "><a href="universal_rules.html"><strong aria-hidden="true">7.</strong> Universal Rules</a></li><li class="chapter-item expanded "><a href="parsable_trait.html"><strong aria-hidden="true">8.</strong> Parsable trait</a></li><li class="chapter-item expanded "><a href="token_iterator.html"><strong aria-hidden="true">9.</strong> TokenIterator</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="wishlist.html"><strong aria-hidden="true">10.</strong> wishlist</a></li><li class="chapter-item expanded "><a href="contributing.html"><strong aria-hidden="true">11.</strong> contributing</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Example book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Astray is a framework for building type safe parsing functions from Rust type definitions. 
It helps you do this with ease and correction.</p>
<p>This doc book is (or hopes to be) a repository for all Astray features and rules. It is, like the rest of the project, a work in progress.</p>
<p>Please check out the <a href="./wishlist.html">wishlist</a> for small breakdown of what has not been implemented so far.</p>
<h2 id="main-goals"><a class="header" href="#main-goals">Main goals</a></h2>
<p>Besides fullfilling its purpose as a parsing framework, Astray has a few non-functional goals:</p>
<ul>
<li>Correctness and type safety over performance (though performance improvements are welcome)</li>
<li>Extensive and prolific use of the Rust type system</li>
<li>Thorough and beginner friendly documentation</li>
</ul>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p>No rules so far, just open an issue and we'll talk about it. Eventually, contributing rules will be made available <a href="./CONTRIBUTING.html">here</a> </p>
<p>Have fun and let me know if something in the book isn't quite right!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="project-structure"><a class="header" href="#project-structure">Project structure</a></h1>
<p>Astray has a front facing <a href="crates.io/crates/astray">crate</a> which combines its two main crates</p>
<ol>
<li><a href="https://github.com/giluis/astray_macro">Astray Macro</a> provides a proc-macro that auto generates parsing functions from Rust type definitions.</li>
<li><a href="https://github.com/giluis/astray_core">Astray Core</a> holds all other functionality besides the proc-macro itself.</li>
</ol>
<p>This division happen because a proc-macro crate may only export proc-macros, and Astray requires additional resources besides the proc-macro itself in order to work.</p>
<p>Let's go over the directory structure for each of these sub-crates</p>
<h2 id="astray-macro"><a class="header" href="#astray-macro">Astray Macro</a></h2>
<p>src/
- lib.rs: exposes relevant macro functionality 
- node.rs: </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-primer-on-compilers"><a class="header" href="#a-primer-on-compilers">A primer on compilers</a></h1>
<p>Let's imagine a programming language called PseudoRust where the only valid statement is:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let &lt;i&gt; = &lt;x&gt; &lt;sign&gt; &lt;y&gt;;
<span class="boring">}</span></code></pre></pre>
<p>Where:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&lt;i&gt;    :=  [a-z]([1-9] | [a-z])*
&lt;x&gt;    :=  [0-9]
&lt;y&gt;    :=  [0-9]
&lt;sign&gt; :=  + | *
<span class="boring">}</span></code></pre></pre>
<p>If confusing, see <a href="https://medium.com/factory-mind/regex-tutorial-a-simple-cheatsheet-by-examples-649dc1c3f285">here</a></p>
<p>Our goal is to write a compiler in Rust that takes PseudoRust text and turns it into machine code for a computer to run.
A compiler can be divided into (at least) 3 steps:</p>
<ol>
<li>Lexing / Tokenization</li>
<li>Parsing</li>
<li>Code Generation</li>
</ol>
<p>Real world compilers include other steps and features like type-checking and optimizations.</p>
<h2 id="1-lexing--tokenization"><a class="header" href="#1-lexing--tokenization">1. Lexing / Tokenization</a></h2>
<p>Tokens (a.k.a lexems) are the smallest meaningful units in a programming language.</p>
<p>E.g. in PseudoRust, the following would be tokens:</p>
<ul>
<li><code>Let</code>: let keyword</li>
<li><code>+</code>: plus sign</li>
<li><code>123</code>: an integer literal</li>
<li><code>abc</code>: an identifier </li>
<li><code>*</code>: asterisk sign</li>
</ul>
<p>Tokens can be easily represented as enums, as seen below.
Other representations might be possible, if you want to store extra information in each token</p>
<p>Lexing means taking as input text representing code as input and transforming it into a list of Tokens.
Take a look at the pseudo-rust found below</p>
<p>For a full tutorial on lexers, check <a href="https://mohitkarekar.com/posts/pl/lexer/">here</a>
Below, an example of how a lexer for the <code>PseudoRust</code> programming language could be typed in Rust: </p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>enum Token {
    LetKw,
    Plus,
    Asterisk,
    IntLiteral(u32),
    Identifier(String),
}

/* Example of storing additional data
struct TokenStruct {
    index_in_source: usize,
    token_len: usize,
    token_type: Token
}*/


fn lex(text: &amp;str) -&gt; Vec&lt;Token&gt; {
    /* Loop through the text, find tokens. Record additional data if needed  */
}

<span class="boring">}</span></code></pre></pre>
<h2 id="2-parsing"><a class="header" href="#2-parsing">2. Parsing</a></h2>
<p>Lexing gives us a list of meaningful building blocks. Out compiler should now check that these building blocks are arranged in accordance with the language's syntax.
A way to do this is by parsing the Tokens into an <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">Abstract Syntax Tree (AST)</a>, which asserts meaningful logical relationships between tokens according to syntax rules.</p>
<p>Let's take a look at how a parse function could work:
E.g The foloowing <code>PseudoRust</code> source file:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // PseudoRust
    let a = 1 + 3;
<span class="boring">}</span></code></pre></pre>
<p>... could be lexed into these tokens:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // the product of our PseudoRust lexer
    vec![ Token::LetKw, Token::Identifier(&quot;a&quot;),
        Token::IntLiteral(1), Token::Plus,
        Token::IntLiteral(3)
    ]
<span class="boring">}</span></code></pre></pre>
<p>... and, given the following AST definition:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    struct AST {
        // Token::LetKw
        let_kw: Token
        var_ident: String,
        // Token::EqualSign
        equals_sign: Token,
        body: Expr,
        // Token::SemiColon
        semicolon: Token,
    }


    struct Expr {
        // Token::LiteralInt(_)
        left: Token
        sign: Sign,
        // Token::LiteralInt(_)
        right: u32
    }

    // Token::Plus | Token::Asterisk
    enum Sign {
        Add
        Mult
    }
<span class="boring">}</span></code></pre></pre>
<p>... and parse function:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn parse(tokens: &amp;[Token]) -&gt; AST {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>... the Tokens could be parsed into:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    AST {
        let_kw: Token::LetKw,
        var_ident: &quot;a&quot;.to_owned(),
        equals_sign: Token::EqualsSign,
        body: Expr {
            left: Token::LiteralInt(1),
            sign: Sign::Add,
            right: Token::LiteralInt(3),
        },
        semicolon: Token::Semicolon,
    }
<span class="boring">}</span></code></pre></pre>
<p>This AST let's us know that this item is an assignment, using the <code>let</code> keyword of the result of <code>(1 + 3)</code> to the identifier &quot;a&quot;. </p>
<p>Note 1:
Our PseudoRust syntax is quite simple. For more complex syntaxes, some new challenges start to arise.
I recommend Nora Sandler's excellent guide on <a href="https://norasandler.com/2017/11/29/Write-a-Compiler.html">building a compiler</a>, so you can understand these challenges.
Note 2: 
Some of these fields could perhaps be dropped from the AST. 
As an example, the equals sign token doesn't have any use here, since we already typed this statement as being an Assignment.</p>
<p>Note 3:
Sometimes, storing the whole token might not be necessary, and maybe we'll just include type it contains in the AST, like we see in <code>var_ident</code> field <code>Assignment</code>. </p>
<h2 id="25-error-handling"><a class="header" href="#25-error-handling">2.5 Error Handling</a></h2>
<p>In practice, any step of our compiler might fail:
When Lexing, maybe some unrecognized tokens are present in the source text:
<code>let a = 1 👍 3;</code>
According to our grammar, this statement is un-lexable and so lexing should fail</p>
<p>Even if lexing succeeds, maybe parsing will fail if there are no syntax rules to explain the tokens that were produced by the lexer:
<code>let a let a = 1 + 3;</code><br />
Though all tokens were valid <code>let a let a</code> has no meaning according to our syntax, so parsing should fail.</p>
<p>Code generation from an AST is more straightforward than the previous steps and would, in this case, maybe only fail if there was some compatibility issue with the target architecture, or something like that.</p>
<p>So, in practice, all our steps should produce <code>Result</code>s rather than just values.</p>
<h2 id="3-code-generation"><a class="header" href="#3-code-generation">3. Code Generation</a></h2>
<h3 id="31-generating-assembly"><a class="header" href="#31-generating-assembly">3.1 Generating Assembly</a></h3>
<p>Our computers really only care about machine code, a binary language that represents instructions for our CPU to execute.
Machine code is rather unsavory for our simple human minds, so, instead, we'll think about a human readable version of machine code: <strong>Assembly</strong>.
Turning an AST into Assembly is off the scope of this project and repository, but feel free to check Nora Sandler's <a href="https://norasandler.com/2017/11/29/Write-a-Compiler.html">guide</a>.</p>
<p>In the end, our compiler would look something like this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn compiler(text: &amp;str) -&gt; Result&lt;String,CompileTimeError&gt; {
    let tokens: Vec&lt;Token&gt; = lex(text)?;
    let ast: AST  = parse(tokens)?;
    generate_assembly(ast)
}

fn generate_assembly(ast: AST) -&gt; Result&lt;String, ParseError &gt; {
    //...
}
<span class="boring">}</span></code></pre></pre>
<h3 id="32-assembling-assembly-into-machine-code"><a class="header" href="#32-assembling-assembly-into-machine-code">3.2 Assembling Assembly into Machine Code</a></h3>
<p>Assembling is the process of turning Assembly into machine code. It's a <em>relativelly</em> straightforward process, where each Assembly instruction is turned into 1 or more machine code instrutions. 
This process is very well studied, highly optimized and, once again, off the scope of this project.
Important note: very often, compilers will transform an AST directly into machine code, skipping 3.1 entirelly. This makes sense, since likely no one will look at whatever the output of this phase is, hence no need for human readable output.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-astray"><a class="header" href="#what-is-astray">What is Astray?</a></h1>
<p>In our <a href="./compiler_primer.html">compiler primer</a>, we saw that compilation of a programming language is usually broken down in at least 3 phases:</p>
<ol>
<li>Lexing (text -&gt; Tokens)</li>
<li>Parsing (Tokens -&gt; AST)</li>
<li>Code generation (AST -&gt; Assembly)</li>
<li>Assembling (Assembly -&gt; Machine Code)</li>
</ol>
<p>Astray highjacks development in step 2 of this list: building a parser.
More specifically, Astray can generate parsing functions for any AST definition, just using a few derive annotations and some attributes.
To get a feel for why this is useful, let'ci's compare a parse function with and without Astray.</p>
<h2 id="parser-implemented-by-hand"><a class="header" href="#parser-implemented-by-hand">Parser implemented by hand</a></h2>
<p>In more detail, let's think about the previous page' example of a parsing function and try to implement it by hand.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/**
* Syntax:
* let &lt;i&gt; = &lt;x&gt; &lt;sign&gt; &lt;y&gt;;
* Where:
* - &lt;i&gt;    :=  [a-z]([1-9] | [a-z])*
* - &lt;x&gt;    :=  [0-9];
* - &lt;y&gt;    :=  [0-9];
* - &lt;sign&gt; :=  + | *;

* Check [here](./compiler_primer.md#2-parsing) for AST defintion
*/
fn parse(tokens: &amp;[Token]) -&gt; Result&lt;AST, String&gt; {
    let mut token_ptr = 0;
    /*parse let kw*/
    match  = tokens.get(token_ptr)  {
        Some(Token::LetKw) =&gt; (),
        _ =&gt;return Err(format!(&quot;Failed to parse 'let' keyword at {token_ptr}&quot;))
    }
    // move on to next token
    token_ptr += 1;

    /*parse variable identifier */
    let var_ident =  match  tokens.get(token_ptr)  {
        Some( Token::Identifier(var_ident)) =&gt; var_ident
        _ =&gt;return Err(format!(&quot;Failed to parse identifier of variable at {token_ptr}&quot;))
    }
    // move on to next token
    token_ptr += 1;

    /*parse equal sign */
     match tokens.get(token_ptr)  {
Some(Token::EqualSign) =&gt; (),
_ =&gt; return Err(format!(&quot;Failed to parse '=' at {token_ptr}&quot;))
     }
    // move on to next token
    token_ptr += 1;

    /*parse left side of expr*/
    let left =  match tokens.get(token_ptr)  {
        Some(left @ Token::IntLiteral(_)) =&gt; left,
        _ =&gt; return Err(format!(&quot;Failed to parse integer literal at {token_ptr}&quot;))
    }
    // move on to next token
    token_ptr += 1;

    /* parse sign (+ or *) */
    let sign = match tokens.get(token_ptr)  {
        Some(Token::Plus) =&gt; Sign::Add
        Some(Token::Asterisk) =&gt; Sign::Mult
        _ =&gt; return Err(format!(&quot;Failed to parse + or * at {token_ptr}&quot;))

    }

    // move on to next token
    token_ptr += 1;

    /*parse right side of expr*/
    let right =  match tokens.get(token_ptr)  {
        Some(right @ Token::IntLiteral(_)) =&gt; right,
        _ =&gt; return Err(format!(&quot;Failed to parse integer literal at {token_ptr}&quot;))
    }
    // move on to next token
    token_ptr += 1;

    /* parse semi colon*/
    match tokens.get(token_ptr)  {
        Some(Token::SemiColon) =&gt; (),
        _ =&gt; return Err(format!(&quot;Failed to parse '=' at {token_ptr}&quot;))
    }
    // move on to next token
    token_ptr += 1;

    // if there any tokens besides these, error
    if token_ptr != tokens.len(){
        return Err(&quot;There were too many tokens&quot;)
    }

    Ok(AST {
        let_kw: Token::LetKw,
        var_ident,
        equals_sign: Token::EqualSign,
        body: Expr {
            left,
            sign,
            right,
        }
        semicolon: Token::SemiColon
    })

}
<span class="boring">}</span></code></pre></pre>
<p>There are a bunch of obvious problems with this implementation:</p>
<ol>
<li>Precise manipulation of a pointer to tokens might foment logic errors, since it gives us a lot of freedom, especially if we ever need to backtrack</li>
<li>Very repetitive code. We could make it smaller with some abstractions, but it would still be quite repetitive for larger, more complex syntaxes.</li>
<li>No mechanism for reusing </li>
</ol>
<p>Now, imagine a syntax like <a href="https://doc.rust-lang.org/stable/reference/">Rust's</a>. Building parsing functions for it is a tremendously difficult job that grows quickly.</p>
<h2 id="astray-to-the-rescue"><a class="header" href="#astray-to-the-rescue">Astray to the rescue</a></h2>
<p>Luckily, Astray can help us with parsing functions.</p>
<p>Given any set of structs or enums representing an AST, Astray will generate type-safe parsing functions for each of those types.
It allows you to compose types to generate complex ASTs without a hassle</p>
<p>So, for our previous AST definition, we would have to add some macros:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    #[derive(SN)]
    struct AST {
        #[pat(Token::LetKw)] 
        let_kw: Token
        #[extract(Token::Identifier(var_ident))] 
        var_ident: String,
        #[pat(Token::EqualSign)] 
        equals_sign: Token,
        body: Expr,
        #[pat(Token::SemiColon)] 
        semicolon: Token,
    }


    #[derive(SN)]
    struct Expr {
        #[pat(Token::LiteralInt(_))]
        left: Token
        sign: Sign,
        #[pat(Token::LiteralInt(_))]
        right: u32
    }

    #[derive(SN)]
    enum Sign {
        #[pat(Token::Plus)]
        Add
        #[pat(Token::Mult)]
        Mult
    }
<span class="boring">}</span></code></pre></pre>
<p>Now, instead of using comments to denote what Tokens are expected, we use <code>pat(&lt;token pattern&gt;)</code>. 
We annotate each type with a <code>#derive[SN]</code> to let Astray know to implement parsing functions for this particular type.</p>
<p>Now, it's pretty easy to use our parser</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn parser () {
    let tokens: Vec&lt;Token&gt; = lex(&quot;let a = 1 + 1;&quot;)
    // `parse` is now an associated function
    let ast: Result&lt;AST, ParseError&gt; = AST::parse(tokens.into());
}

<span class="boring">}</span></code></pre></pre>
<p><strong>Feature breakdown</strong></p>
<ul>
<li>Parse a sequence of types, represented as a <code>struct</code></li>
<li>Parse one of many possible types, represented as an <code>enum</code></li>
<li>Pattern Matching on Tokens</li>
<li>Vec<T>: for consuming multiple types or Tokens</li>
<li>Option<T>: for consuming a type if it is there</li>
<li>Box<T>: for consuming and heap allocating a type</li>
<li>(T,P): for tuples of types (only arity &lt;=3 implemented for now)</li>
<li>Either&lt;T,P&gt;: from the <a href="https://crates.io/crates/either">either</a> crate</li>
<li>NonEmpty<T>: from the <a href="https://crates.io/crates/nonempty">nonempty</a> crate, allows you to consume a sequence of at least one type</li>
</ul>
<p>For more details, keep reading the book!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basics"><a class="header" href="#basics">Basics</a></h1>
<p>So, Astray is a framework to develop parsing functions from Rust type definitions.
It provides 2 basic components, each a separate crate:</p>
<p>The core of Astray is the <code>Parsable</code> trait, which can be automatically derived with the <code>SN</code> (&quot;Syntax Node&quot;) macro.
Just annotating a type with <code>SN</code> will auto generate an implementation of <code>Parsable</code> , as we'll see in the next chapter.</p>
<p>At the heart of Astray lies the SN macro, a derive-macro that takes a type definition and builds a parsing function for it. We'll cover some basic examples in the next chapter</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-types"><a class="header" href="#basic-types">Basic types</a></h1>
<p>Almost any type can derive the <code>SN</code> macro. This auto implements the <code>Parsable&lt;T&gt;</code> trait, which comes with the  <code>parse</code> associated function:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Parsable&lt;T&gt; {
    fn parse(token_iter: TokenIterator&lt;T&gt;) -&gt; Result&lt;Self, ParseError&lt;T&gt;&gt;;
    /// other stuff we'll discuss later*
}
<span class="boring">}</span></code></pre></pre>
<p>A TokenIterator is an abstraction over a Vec of Tokens that can go iterate bidirectionally and do a bunch of useful stuff. We'll cover it <a href="./token_iterator.html">later</a>.</p>
<p>Before doing anything with Astray, the user must call the <code>set_token!(&lt;your_token_type&gt;)</code> macro to let Astray know what type will be considered a token for the parsing functions it will generate.</p>
<h2 id="structs-and-pattern-matching"><a class="header" href="#structs-and-pattern-matching">structs and pattern matching</a></h2>
<p>When a <code>struct</code> derives <code>SN</code>, Parsable<T> is auto implemented. You can call the parse function like this:</p>
<pre><pre class="playground"><code class="language-rust edition2021">set_token!(Token)

#[derive(SN)]
struct Pair{
    l_element: Token,
    comma: Token,
    r_element: Token,
}

fn main() {
    // let tokens = lexer(&quot;a b c&quot;); This will be parsed successfully as well
    let tokens = lexer(&quot;a , c&quot;);
    assert_eq!(tokens, vec![
        Token::Identifier(&quot;a&quot;.to_owned())
        Token::Comma
        Token::Identifier(&quot;c&quot;.to_owned())
    ])
    let pair: Result&lt;Pair, ParseError&lt;Token&gt;&gt; = Pair::parse(tokens.into())
}</code></pre></pre>
<p>Struct fields will be parsed top to bottom. <em>If any of the fields cannot be parsed, the struct will fail parsing as well.</em></p>
<p>The code above will actually parse any set of 3 tokens, since we have not specified which tokens should be consumed. We can do so with pattern matching, which we'll see next.</p>
<p>I'm working on support for Tuple Structs:
TODO: Insert issue number here <a href=""></a></p>
<pre><pre class="playground"><code class="language-rust edition2021">set_token!(Token);

#[derive(SN)]
struct TwoNumbers(Token, Token);

fn main() {
    let tokens = lexer(&quot;1 2&quot;);
    assert_eq!(tokens, vec![
        Token::IntLiteral(1)
        Token::Identifier(2)
    ]);

    let two_numbers: Result&lt;TwoNumbers, ParseError&lt;Token&gt;&gt; = TwoNumbers::parse(tokens.into())
}</code></pre></pre>
<h2 id="pattern-matching"><a class="header" href="#pattern-matching">pattern matching</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enums"><a class="header" href="#enums">Enums</a></h1>
<p>Much like structs, enums can be used as consumable types.
Astray will try to parse each of the enum's variants from top to bottom.
<strong>If all variants fail to parse, the enum fails to parse</strong>
<strong>If at least one variant does parse, the enum parsing succeeds</strong>
All enums derive SN, as long as they follow the guidelines in the notes below:</p>
<h2 id="enum-note-1-unit-variants-must-have-a-pat-attribute-annotation"><a class="header" href="#enum-note-1-unit-variants-must-have-a-pat-attribute-annotation">Enum Note 1: Unit variants must have a #[pat] attribute annotation</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/*valid*/
#[derive(SN)]
enum Sign {
    #[pat(Token::Plus)]
    Plus,
    #[pat(Token::Minus)]
    Minus,
}

/*invalid, fails to compile*/
#[derive(SN)]
enum Sign {
    Plus,
    Minus,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="enum-note-2-single-tuple-variants-only"><a class="header" href="#enum-note-2-single-tuple-variants-only">Enum Note 2: Single Tuple variants only</a></h2>
<p>Use single element tuple variants that contain a tuple instead of tuple variants with many elements.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>enum Sign {
    #[pat(Token::Plus)]
    Plus(Token),
    // valid 
    #[pat(Token::Slash)]
    Div((Token)),
    // invalid, fails to compile 
    IntegerDiv(Token, Token),
    // valid, applies pattern to tuple
    #[pat((Token::Slash, Token::Slash))]
    IntegerDiv((Token, Token)),
}
<span class="boring">}</span></code></pre></pre>
<p><strong>struct variants are not supported <em>yet</em></strong></p>
<p>TODO: Add support for this and mention tracking issue here</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pattern-matching-1"><a class="header" href="#pattern-matching-1">Pattern Matching</a></h1>
<p>You can pattern match on each field in a struct (or enum, as we'll see later) to tell Astray that it should parse a specific instance of a Token (or type) for that specific field.</p>
<h2 id="no-pattern-matching"><a class="header" href="#no-pattern-matching">No Pattern matching</a></h2>
<p>If pattern matching is not specified, then any instance of that type may be parsed. This includes Tokens:</p>
<pre><pre class="playground"><code class="language-rust edition2021">set_token!(Token)

#[derive(SN)]
struct Pair{
    l_element: Token,
    comma: Token,
    r_element: Token,
}

fn main() {
    let tokens = lexer(&quot;a b c&quot;);
    assert_eq!(tokens, vec![
        Token::Identifier(&quot;a&quot;.to_owned())
        Token::Identifier(&quot;b&quot;.to_owned())
        Token::Identifier(&quot;c&quot;.to_owned())
    ])
    // Any three tokens will be successfully parsed. This is pretty useless
    let pair: Result&lt;Pair, ParseError&lt;Token&gt;&gt; = Pair::parse(tokens.into())
}</code></pre></pre>
<p>Of course, parsing Tokens without a specific</p>
<h2 id="with-pattern-matching"><a class="header" href="#with-pattern-matching">With pattern matching</a></h2>
<p>If the user wants to parse a specific instance of a type, annotate the desired field with the pattern that field is expected to have. </p>
<pre><pre class="playground"><code class="language-rust edition2021">set_token!(Token)

#[derive(SN)]
struct Pair{
    #[pat(Token::Identifier(_))]
    l_element: Token,
    #[pat(Token::Comma)]
    comma: Token,
    #[pat(Token::Identifier(_))]
    r_element: Token,
}

fn main() {
    let tokens = [
        Token::Identifier(&quot;a&quot;.to_owned()),
        Token::Identifier(&quot;b&quot;.to_owned()),
        Token::Identifier(&quot;c&quot;.to_owned()),
    ]
    // result is err
    let pair: Result&lt;Pair, ParseError&lt;Token&gt;&gt; = Pair::parse(tokens.into())
    assert!(pair.is_err());

    let tokens = [
        Token::Identifier(&quot;a&quot;.to_owned()),
        Token::Comma,
        Token::Identifier(&quot;c&quot;.to_owned()),
    ];
    let pair: Result&lt;Pair, ParseError&lt;Token&gt;&gt; = Pair::parse(tokens.into())
    assert_eq!(pair, Ok(Pair {
        l_element: Token::Identifier(&quot;a&quot;.to_owned()),
        comma: Token::Comma,
        r_element : Token::Identifier(&quot;c&quot;.to_owned()),
    }))
}</code></pre></pre>
<p>Of course this works for all parsable types, not just tokens:</p>
<pre><pre class="playground"><code class="language-rust edition2021">struct Expr {
    #[pat(Token::IntLiteral(_))]
    left: Token,
    #[pat(Sign::Add)]
    sign: Sign,
    #[pat(Token::IntLiteral(_))]
    right: Token,
}

enum Sign {
    #[pat(Token::Plus)]
    Add,
    #[pat(Token::Minus)]
    Sub,
}


fn main() {
    let tokens = [
        Token::IntLiteral(3),
        Token::Plus,
        Token::IntLiteral(2),
    ]
    let expr_result = Expr::parse(tokens.into());
    assert_eq!(expr_result, Ok(
        Expr {
            left: Token::IntLiteral(3),
            sign: Sign::Add
            right: Token::IntLiteral(2),
        }
    ))

    let tokens = [
        Token::IntLiteral(3),
        Token::Minus,
        Token::IntLiteral(2),
    ]
    let expr_result = Expr::parse(tokens.into());
    // Does not parse, since Expr is expecting specifically a Sign::Add, which may not be parsed when Token::Minus is present instead of Token::Plus
    assert!(expr_result.is_err())
}</code></pre></pre>
<h2 id="extract-values"><a class="header" href="#extract-values">Extract values</a></h2>
<p>Currently a WIP, you can extract specific values form a matched pattern, should you want to keep only the inner values of a struct / enum in your AST</p>
<pre><pre class="playground"><code class="language-rust edition2021">set_token!(Token)

#[derive(SN)]
struct Pair{
    #[extract(Token::Identifier(l_element))]
    l_element: String,
    #[pat(Token::Comma)]
    comma: Token,
    #[extract(Token::Identifier(r_element))]
    r_element: String,
}

fn main() {
    let tokens = [
        Token::Identifier(&quot;a&quot;.to_owned()),
        Token::Comma,
        Token::Identifier(&quot;c&quot;.to_owned()),
    ];
    let pair: Result&lt;Pair, ParseError&lt;Token&gt;&gt; = Pair::parse(tokens.into())
    assert_eq!(pair, Ok(Pair {
        l_element: &quot;a&quot;.to_owned(),
        comma: Token::Comma,
        r_element : &quot;c&quot;.to_owned(),
    }))
}</code></pre></pre>
<h2 id="either-this-or-that"><a class="header" href="#either-this-or-that">Either this or that</a></h2>
<p>As you'd expect, it's possible to use patterns with pipes to make Astray parse one possible type from a set of types. 
This can be a replacement for moving a type to a separate enum, and will very likely be faster. 
TODO: Benchmark this</p>
<pre><pre class="playground"><code class="language-rust edition2021">set_token!(Token)

#[derive(SN)]
struct Pair{
    #[extract(Token::Identifier(l_element))]
    l_element: String,
    #[pat(Token::Comma | Token::SemiColon)]
    comma: Token,
    #[extract(Token::Identifier(r_element))]
    r_element: String,
}

fn main() {
    let tokens = [
        Token::Identifier(&quot;a&quot;.to_owned()),
        Token::Identifier(&quot;,&quot;.to_owned()),
        Token::Identifier(&quot;c&quot;.to_owned()),
    ]

    let pair: Result&lt;Pair, ParseError&lt;Token&gt;&gt; = Pair::parse(tokens.into())
    assert_eq!(pair, Ok(Pair {
        l_element: &quot;a&quot;.to_owned(),
        comma: Token::Comma,
        r_element : &quot;c&quot;.to_owned(),
    }))

    let tokens = [
        Token::Identifier(&quot;a&quot;.to_owned()),
        Token::Comma,
        Token::Identifier(&quot;c&quot;.to_owned()),
    ];
    let pair: Result&lt;Pair, ParseError&lt;Token&gt;&gt; = Pair::parse(tokens.into())
    assert_eq!(pair, Ok(Pair {
        l_element: &quot;a&quot;.to_owned(),
        comma: Token::Comma,
        r_element : &quot;c&quot;.to_owned(),
    }))
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-types"><a class="header" href="#custom-types">Custom Types</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-types-1"><a class="header" href="#custom-types-1">Custom Types</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="errors"><a class="header" href="#errors">Errors</a></h1>
<p>As a general rule,  &lt;P as Parsable<T>&gt;::parse(...) and &lt;P as Parsable<T>&gt;::parse_if_match(...) both produce a Result&lt;P, ParseError<T>&gt;, where T: Parsable<T>. </p>
<p>This means that all parsing is fallible. If it does fail, a ParseError<T> is produced.
Check its definition below:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, PartialEq, Eq)]
pub enum ParseErrorType&lt;T&gt;
where
    T: ConsumableToken,
{
    /* Since Tokens are just parsable types, this might be removed in the future*/
    UnexpectedToken { expected: T, found: T },
    /* When you run out of tokens mid parsing a type */
    NoMoreTokens,
    /* When a type can be parsed from the TokenIterator but it does not match the pattern that was applied to it */
    ParsedButUnmatching { err_msg: String }, 
    /**
     * Failed to parse a branch from a conjunct type
     *  This will happen for:
     * - fields /elements in a struct / tuple struct
     * - elements in a tuple
     * - the first element in a NonEmpty vec
     */
    ConjunctBranchParsingFailure { err_source: Box&lt;ParseError&lt;T&gt;&gt; },
    /**
     * Failed to parse a branch from a conjunct type
     *  This will happen for:
     * - variants in an enum
     * - fields in Either
     */
    DisjunctBranchParsingFailure { err_source: Vec&lt;ParseError&lt;T&gt;&gt; },
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct ParseError&lt;T&gt;
where
    T: ConsumableToken,
{
    type_name: &amp;'static str,
    failed_at: usize,
    pub failure_type: ParseErrorType&lt;T&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>As you can see, a ParseError can have 5 differnent causes.
Check the comments in each for further details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="astray-universal-rules"><a class="header" href="#astray-universal-rules">Astray Universal Rules</a></h1>
<p>This is a complex project, so below are some rules/axioms/definitions that <em>must</em> be upheld throughout. If at any point the code/docs fail to a single one of these, then there's a bug either in the code/docs, or in the rules. </p>
<p>Throughout the code and docs, AUR::N will be the way to reference the Nth rule, as specified below:</p>
<ol>
<li>Given any type <code>T</code> and a <code>TokenIterator&lt;T&gt;</code>, where <code>T: Parsable&lt;T&gt;</code>, <code>T</code> will referred to as a <code>Token</code>.</li>
<li>Given any type <code>P: Parsable&lt;T&gt;, T: Parsable&lt;T&gt;</code> P may be parsed from a TokenIterator<T>. P will be called a &quot;parsable type&quot;, or just a &quot;parsable&quot;</li>
<li>Since T: Parsable<T>, for all T, T may always be parsed from TokenIterator<T>.
<ul>
<li>This means a Token will always be parsable from a TokenIterator<T> of itself.</li>
<li>All T: Parsable<T> </li>
</ul>
</li>
<li>Parsable types are either Tokens, or composed of other parsable types through sum types or product types. </li>
<li>Parsing may fail, so it always produces a Result&lt;P, ParseError<T>&gt;, where P: Parsable<T> </li>
<li>A failed parsing will always leave the TokenIterator at the place it was before parsing was attempted. This is true for all structs, enums and <a href="./additional_types.html">default implementations</a> in Astray and should remain true for any custom types the user implements.</li>
<li>A successful parsing can either leave the iterator in the same place it was before parsing was attempted, or move the iterator along according to the length of the type it is parsing. Check <a href="./additional_types.html#option">here</a> if confusing</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h3 id="the-parsable-trait"><a class="header" href="#the-parsable-trait">The Parsable<T> trait</a></h3>
<p>At the heart of Astray lies the <code>Parsable&lt;T&gt;</code> trait. Check its definition <a href="https://github.com/giluis/astray_core/main/blob/src/parsable.rs">here</a>. 
<code>Parsable&lt;T&gt;</code> marks a type as consumable type. This means that given a <code>TokenIterator&lt;T&gt;</code>, any struct implementing <code>Parsable&lt;T&gt;</code> may be parsed from those tokens.</p>
<p>Its definition:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span>

<span class="boring">fn main() {
</span>pub trait Parsable&lt;T&gt;: std::fmt::Debug
where
    T: Parsable&lt;T&gt;,
    Self: Sized,
    T: ConsumableToken

{
    type ApplyMatchTo: Parsable&lt;T&gt; = Self;

    fn parse(iter: &amp;mut TokenIter&lt;T&gt;) -&gt; Result&lt;Self, ParseError&lt;T&gt;&gt;;

    fn parse_if_match&lt;F: Fn(&amp;Self::ApplyMatchTo) -&gt; bool&gt;(
        iter: &amp;mut TokenIter&lt;T&gt;,
        matches: F,
        pattern: Option&lt;&amp;'static str&gt;
    ) -&gt; Result&lt;Self, ParseError&lt;T&gt;&gt;
    where
        Self: Sized {
            todo!(&quot;parse_if_match not yet implemented for {:?}&quot;, Self::identifier());
        }
    

    fn identifier() -&gt; &amp;'static str {
        std::any::type_name::&lt;Self&gt;()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Let's go step by step</p>
<h3 id="trait-declaration"><a class="header" href="#trait-declaration">Trait declaration</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Any type that implements Parsable&lt;T&gt; must implement std::fmt::Debug
// This is necessary for building nice ParseErrors
pub trait Parsable&lt;T&gt;: std::fmt::Debug
where
    // T: Parsable&lt;T&gt;, meaning T is a Token as per Astray Rule # 1
    T: Parsable&lt;T&gt;,
    // Self is Sized is required, since parse and parse_if_match associated functions return Self
    Self: Sized,
    // This is just a marker trait, that might be removed in the future
    T: ConsumableToken
<span class="boring">}</span></code></pre></pre>
<h3 id="associated-type"><a class="header" href="#associated-type">Associated Type</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    type ApplyMatchTo: Parsable&lt;T&gt; = Self
}
<span class="boring">}</span></code></pre></pre>
<p>This is the type that patterns will be applied to when <code>#[pat(&lt;pattern&gt;)]</code> is used.
Generally, it will be Self. However, for <a href="./additional_types.html#option">container types</a>, ApplyMatchTo might be the contained type.
ApplyMatchTo may be any type that makes sense for each specific implementor of Parsable.
Check this page on <a href="./custom_types.html">implementing Parsable<T> by hand</a> for an example.</p>
<h3 id="parse-function"><a class="header" href="#parse-function">parse function</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn parse(iter: &amp;mut TokenIter&lt;T&gt;) -&gt; Result&lt;Self, ParseError&lt;T&gt;&gt;;
<span class="boring">}</span></code></pre></pre>
<p>Parse takes <code>&amp;mut TokenIterator&lt;T&gt;</code>, which must be mut since the inner pointer in TokenIterator will be moved depending on what the parsing function does.
<code>parse</code> will always return a Result, meaning it is always fallible.</p>
<h3 id="parse-function-1"><a class="header" href="#parse-function-1">parse function</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn parse_if_match&lt;F: Fn(&amp;Self::ApplyMatchTo) -&gt; bool&gt;(
    _iter: &amp;mut TokenIter&lt;T&gt;,
    _matches: F,
    _pattern: Option&lt;&amp;'static str&gt;
) -&gt; Result&lt;Self, ParseError&lt;T&gt;&gt;
where
    Self: Sized {
        todo!(&quot;parse_if_match not yet implemented for {:?}&quot;, Self::identifier());
    }
<span class="boring">}</span></code></pre></pre>
<p>The <code>parse_if_match</code> function will allow an implementor to restrict which types can be parsed according to a validating function, here named <code>matches</code> (TODO: might be renamed in the future). 
Ideally, we would be able to pass a pattern directly to this function, but Rust doesn't really have first class support for patterns, so a <code>Fn(&amp;Self::ApplyMatchTo) -&gt; bool</code> does the trick. In practice, the function that actually passed to <code>parse_if_match</code> is <code>|ty|matches!(ty, &lt;pattern&gt;)</code>.</p>
<p><code>parse_if_match</code> requires a <code>pattern</code> string which is a stringified version of a pattern.
Since Rust doesn't really have first class support for patterns, a <code>matches</code> which would very useful. So</p>
<p>TODO: A default implementation is on the way.</p>
<p>Given a <code>token_iterator: TokenIterator&lt;T&gt;</code> and <code>P: Parsable&lt;T&gt;</code>:</p>
<ol>
<li><code>P</code> shall called a parsable type </li>
<li><code>P</code> may be parsed from token iterator with <code>P::parse(&amp;mut token_iterator)</code></li>
<li><code>P::parse(&amp;mut token_iterator)</code> always produces:
<ul>
<li><code>Ok(P {/*fields*/})</code> if parsing succeeds. The iterator is left at the position pointing to the token after the last token that was consumed for parsing <code>P</code></li>
<li><code>Err(ParseError&lt;T&gt; /*different errors exist*/)</code>. In this case, the iterator is reset to the position it was before parsing was attempted</li>
</ul>
</li>
<li><code>T: Parsable&lt;T&gt;</code> (<a href="./features.html#notes">with some caveats</a>)
<ul>
<li>Calling <code>&lt;Token as Parsable&lt;Token&gt;&gt;::parse(&amp;mut token_iterator)</code> just consumes the next token</li>
</ul>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="define-a-set-of-universal-rules-for-astray"><a class="header" href="#define-a-set-of-universal-rules-for-astray">Define a set of universal rules for Astray</a></h1>
<p>Astray is complex and must follow some rulessarily These are being defined (WIP) at (./universal_rules.md)</p>
<h1 id="implement-iterator-for-tokeniterator"><a class="header" href="#implement-iterator-for-tokeniterator">Implement Iterator<T> for TokenIterator<T></a></h1>
<ul>
<li>Allows usage of iterator methods</li>
<li>replaces <code>fn consume(&amp;mut self)</code> with <code>fn next(&amp;mut self)</code>, which is more intuitive in Rust land</li>
<li>Prevents iterator from going backwards, of course. So it would not work on sum types.</li>
</ul>
<h1 id="functional-macro-for-enum-optimization"><a class="header" href="#functional-macro-for-enum-optimization">Functional macro for enum optimization</a></h1>
<p>When an enum implements Parsable<T>, its branches can have common parsing paths!</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum MyEnum {
    Variant1(Struct1),
    Variant2(Struct2),
}

struct Struct1 {
    #[pat(Token::Plus)]
    plus: Token
    #[pat(Token::LiteralInt(_))]
    plus: TOken
}

struct Struct2 {
    #[pat(Token::Plus)]
    plus: Token
    #[pat(Token::LiteralString(_))]
    plus: TOken
}
<span class="boring">}</span></code></pre></pre>
<p>Given a <code>TokenIterator</code> over <code>[Token:Plus, TokenLiteralString(&quot;something&quot;)]</code>, Astray tries to parse a Plus (for a Struct1), succeeds and tries to parse a LiteralInt(_), fails, tries to parse a Plus again (for Struct2) and then a LiteralString (succeeds).
Plus has been tried twice unnecessarilly.
The goal is to optimize this. I already have an idea for execution, which I will expose later as soon as I can.</p>
<h1 id="parsing-visualization-for-the-command-line-bonus-points-if-also-works-in-the-browser"><a class="header" href="#parsing-visualization-for-the-command-line-bonus-points-if-also-works-in-the-browser">Parsing visualization for the command line (bonus points if also works in the browser)</a></h1>
<p>An animation of how parsing is happening in &quot;real&quot; time, showing how the parser works.</p>
<h1 id="documenting-all-functions-in-the-code"><a class="header" href="#documenting-all-functions-in-the-code">Documenting all functions in the code</a></h1>
<p>Although they are (hopefully) rather self explanatory, great Rusty documentation is missing from each function.
I hope to add it in the future.</p>
<h1 id="updating-nomenclature"><a class="header" href="#updating-nomenclature">Updating nomenclature</a></h1>
<p>Consumable types -&gt; Parsable types
Partially in docs, WIP in the code.</p>
<h1 id="generic-errors-instead-of-parseerror"><a class="header" href="#generic-errors-instead-of-parseerror">Generic Errors instead of ParseError</a></h1>
<p>Turning ParseError into a trait allows users to specify what Error type their parsing functions to produce.</p>
<h1 id="implement-fromiterator-for-tokeniterator"><a class="header" href="#implement-fromiterator-for-tokeniterator">Implement FromIterator for TokenIterator</a></h1>
<p>Makes it easier to create a TokenIterator, rather.</p>
<h1 id="update-parse_if_match-function"><a class="header" href="#update-parse_if_match-function">Update parse_if_match function</a></h1>
<p>Parsers should be generic not only on type's they take, but also on their arity!
I'm investigating possible solutions for this</p>
<h1 id="add-more-advanced-validation-functions"><a class="header" href="#add-more-advanced-validation-functions">Add more advanced validation functions</a></h1>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct A {
    /* These should get combined into a single validation function? Or maybe multiple validation functinons... more experimentation is required*/
    #[pat(Token::LiteralInt(_))]
    #[len(&gt; 5)]
    field1: Vec&lt;Token&gt;, 
}
<span class="boring">}</span></code></pre></pre>
<p>Perhaps renaming <code>parse_if_match</code> to <code>parse_if_valid</code></p>
<h1 id="remove-unexpectedtoken-parseerrortype-variant"><a class="header" href="#remove-unexpectedtoken-parseerrortype-variant">Remove UnexpectedToken ParseErrorType variant</a></h1>
<p>Since Tokens are to be treated as parsable types, under the specifc restrictions that Token: Parsable<Token>, then Conjunct / Disjunct branch failure error variant should be used, depending on whether the token is an enum or a struct</p>
<h1 id="rename-parseerrortype-to-parseerrorreason"><a class="header" href="#rename-parseerrortype-to-parseerrorreason">Rename ParseErrorType to ParseErrorReason</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing-1"><a class="header" href="#contributing-1">contributing</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
